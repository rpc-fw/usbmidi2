/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : DMA1.c
**     Project     : usbmidi2_master
**     Processor   : MKL26Z64VFM4
**     Component   : DMA_LDD
**     Version     : Component 01.065, Driver 01.07, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-07-12, 00:24, # CodeGen: 68
**     Abstract    :
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
**     Settings    :
**          Component name                                 : DMA1
**          Device                                         : DMA
**          Channel arbitration type                       : Round robin
**          DMA channels                                   : 1
**            Settings of DMA channel                      : DMA_Channel2
**              Channel                                    : DMA_Channel2
**              Channel arbitration type                   : Round robin
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : INT_DMA2
**                Transfer complete interrupt priority     : medium priority
**          Initialization                                 : 
**            Enabled in init. code                        : yes
**            Auto initialization                          : yes
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init            - LDD_TDeviceData* DMA1_Init(LDD_TUserData *UserDataPtr);
**         Deinit          - void DMA1_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         AllocateChannel - LDD_TError DMA1_AllocateChannel(LDD_TDeviceData *DeviceDataPtr,...
**         EnableChannel   - LDD_TError DMA1_EnableChannel(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file DMA1.c
** @version 01.07
** @brief
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
*/         
/*!
**  @addtogroup DMA1_module DMA1 module documentation
**  @{
*/         

/* MODULE DMA1. */

#include "DMA1.h"

/* {Bareboard RTOS Adapter} No RTOS includes */

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static DMA1_TDeviceData DeviceDataPtr__DEFAULT_RTOS_ALLOC;
/* {Bareboard RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA1_TDeviceData * INT_DMA2__BAREBOARD_RTOS_ISRPARAM;
/* Channel numbers initialization table */
static const LDD_DMA_TChannelNumber DMA1_ChannelNumbers[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  0x02U
};
/* Channel interrupts enable initialization table */
static const bool DMA1_ChannelInterrupts[DMA1_CONFIGURED_CHANNELS_NUMBER] = {
  TRUE
};

/* Internal method prototypes */
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA1_TDescriptorRecordPtr *DescriptorRecordAddressPtr);
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr);

/*
** ===================================================================
**     Method      :  DMA1_Init (component DMA_LDD)
*/
/*!
**     @brief
**         Initializes the device according to design-time
**         configuration properties. Allocates memory for the device
**         data structure. 
**         If the <Enable in init. code> is set to "yes" then the
**         device is also enabled (see the description of the Enable
**         method).
**         This method can be called only once. Before the second call
**         of Init the Deinit method must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* DMA1_Init(LDD_TUserData *UserDataPtr)
{
  uint8_t i;
  DMA1_TDeviceData *DeviceDataPtr;     /* LDD device structure */
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPtr = &DeviceDataPtr__DEFAULT_RTOS_ALLOC;
  DeviceDataPtr->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Enable device clock gate */
  /* SIM_SCGC7: DMA=1 */
  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
  /* SIM_SCGC6: DMAMUX=1 */
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;
  /* Transfer compete interrupt vector(s) allocation */
  /* {Bareboard RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA2__BAREBOARD_RTOS_ISRPARAM = DeviceDataPtr;
  /* Transfer compete interrupt vector(s) priority setting */
  /* NVIC_IPR0: PRI_2=0x80 */
  NVIC_IPR0 = (uint32_t)((NVIC_IPR0 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_2(0x7F)
              )) | (uint32_t)(
               NVIC_IP_PRI_2(0x80)
              ));
  /* NVIC_ISER: SETENA|=4 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x04);
  for (i = 0U; i < DMA1_DMA_CHANNELS_NUMBER; i++) {
    DMA_PDD_WriteControlReg(DMA_BASE_PTR, i, 0U); /* Clear control register. Disable all interrupts and HW requests. */
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, i, DMA_PDD_TRANSFER_COMPLETE_FLAG); /* Clear request interrupt flags */
  }
  /* Initialization of channels record field. */
  for(i = 0U; i < DMA1_DMA_CHANNELS_NUMBER; i++) {
    DeviceDataPtr->ChannelRecord[i] = NULL; /* Clear pointer to descriptor record of all channels. */
  }
  /* Initialization of channel and descriptor record fields. */
  for(i = 0U; i < DMA1_CONFIGURED_CHANNELS_NUMBER; i++) {
    DescriptorRecordPtr = &(DeviceDataPtr->DescriptorRecord[i]); /* Store local pointer to descriptor record. */
    DescriptorRecordPtr->ChannelNumber = DMA1_ChannelNumbers[i]; /* Store associated channel number. */
    DescriptorRecordPtr->DescriptorPtr = NULL; /* Set channel as free. */
    DescriptorRecordPtr->Interrupts = DMA1_ChannelInterrupts[i]; /* Store associated channel interrupts enabled/disabled status. */
    DescriptorRecordPtr->Initialized = FALSE; /* Set channel as not initialized. */
    DescriptorRecordPtr->Enabled = FALSE; /* Set channel as disabled. */
    DeviceDataPtr->ChannelRecord[DMA1_ChannelNumbers[i]] = DescriptorRecordPtr; /* Store pointers to descriptor records of fixed channels. */
    DeviceDataPtr->EventMask[DMA1_ChannelNumbers[i]] = 0U; /* Clear channel event mask. */
  }
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DMA1_ID,DeviceDataPtr);
  return ((LDD_TDeviceData *)DeviceDataPtr); /* Return pointer to the data structure */
}

/*
** ===================================================================
**     Method      :  DMA1_Deinit (component DMA_LDD)
*/
/*!
**     @brief
**         Deinitializes the associated peripheral(s) and frees the
**         component internal data structure.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
*/
/* ===================================================================*/
void DMA1_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr;                 /* Parameter not used, suppress not used argument warning */
  /* Restoring the interrupt vectors */
  /* {Bareboard RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DMA1_ID);
  /* Deallocation of the device structure */
  /* {Bareboard RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
  /* Disable device clock gate */
  /* SIM_SCGC7: DMA=0 */
  SIM_SCGC7 &= (uint32_t)~(uint32_t)(SIM_SCGC7_DMA_MASK);
}

/*
** ===================================================================
**     Method      :  DMA1_AllocateChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method allocates DMA channel for the DMA transfer
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This method must be called before DMA channel
**         is initialized. Otherwise ERR_NOTAVAIL error code is
**         returned after call of DMA_LDD channel methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any possible
**                           channel with desired features to be
**                           allocated.
*/
/* ===================================================================*/
LDD_TError DMA1_AllocateChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA1_TDeviceData *LocalDeviceDataPtr = (DMA1_TDeviceData *)DeviceDataPtr; /* Auxiliary variable - pointer to an internal state structure */
  DMA1_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */
  bool ChannelFound = FALSE;

  if (!DescriptorPtr->ChannelAutoSelection) { /* Fixed channel wanted? */
    DescriptorRecordPtr = LocalDeviceDataPtr->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Store local pointer to internal descriptor record. */
    if (DescriptorRecordPtr->DescriptorPtr == NULL) { /* Is channel free? */
      /* Allocate channel */
      DescriptorRecordPtr->DescriptorPtr = DescriptorPtr;
      ChannelFound = TRUE;
    }
  }
  if (ChannelFound) {
    return ERR_OK;
  }
  else {
    return ERR_NOTAVAIL;
  }
}

/*
** ===================================================================
**     Method      :  DMA1_EnableChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method initializes and/or enables the DMA channel
**         allocated for the DMA transfer defined by the transfer
**         descriptor input parameter DescriptorPtr. First call of this
**         method on given DMA channel initializes it and enables HW
**         requests if Peripheral device or Always enabled trigger
**         source is selected in transfer descriptor Trigger source
**         type item. This method can be also used together with
**         Disable method to temporary switch On/Off the DMA channel HW
**         requests. In such case DMA channel registers are not
**         reinitialized again. New initialization of DMA channel can
**         be done via SetChannelDescriptorUpdate method which
**         reinitializes whole channel with new transfer descriptor.
**         After calling of EnableChannel method channel status is set
**         to LDD_DMA_IDLE.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Transfer descriptor data
**                           are inconsistent.
*/
/* ===================================================================*/
LDD_TError DMA1_EnableChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TChannelNumber ChannelNumber;
  DMA1_TDescriptorRecord *DescriptorRecordPtr;

  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!VerifyDescriptor(DescriptorPtr)) {
    return ERR_PARAM_DATA;
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Save local auxiliary channel number. */
  if (!DescriptorRecordPtr->Initialized) { /* Is channel already initialized? */
    /* If channel is not initialized yet, initialize and enable it */
    DMA_PDD_WriteControlReg(DMA_BASE_PTR, ChannelNumber, 0U); /* Clear control register. Disable requests. */
    DMA_PDD_ClearDoneFlag(DMA_BASE_PTR, ChannelNumber); /* Clear DMA transfer done status flag. */
    /* Source address */
    DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddress);
    /* Source address increment */
    if (DescriptorPtr->SourceAddressIncrement) {
      DMA_PDD_EnableSourceAddressIncrement(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Destination address */
    DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddress);
    /* Destination address increment */
    if (DescriptorPtr->DestinationAddressIncrement) {
      DMA_PDD_EnableDestinationAddressIncrement(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Transfer attributes: source transfer size, destination transfer size, source modulo, destination modulo */
    DMA_PDD_SetSourceAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceModuloSize);
    DMA_PDD_SetSourceDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceTransferSize);
    DMA_PDD_SetDestinationAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationModuloSize);
    DMA_PDD_SetDestinationDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationTransferSize);
    /* Transfer mode */
    if (DescriptorPtr->TransferMode == LDD_DMA_CYCLE_STEAL_TRANSFERS) {
      DMA_PDD_EnableCycleSteal(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable cycle-steal mode. */
    }
    /* Byte count */
    DMA_PDD_SetByteCount(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->ByteCount);
    /* Auto-align mode settings. */
    if (DescriptorPtr->AutoAlign) {
      DMA_PDD_EnableAutoAlign(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Asynchronous requests settings. */
    if (DescriptorPtr->AsynchronousRequests) {
      DMA_PDD_EnableAsynchronousRequests(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Channel linking settings. */
    switch (DescriptorPtr->ChannelLinkingMode) {
      case LDD_DMA_LINKING_DISABLED:
        /* Initialization not needed. */
        break;
      case LDD_DMA_CYCLE_STEAL_AND_TRANSFER_COMPLETE_LINKING:
        DMA_PDD_SetChannelLinkingMode(DMA_BASE_PTR, ChannelNumber, DMA_PDD_CYCLE_STEAL_AND_TRANSFER_COMPLETE_LINKING); /* Set channel linking mode. */
        DMA_PDD_SetLinkChannel1(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel); /* Set channel linked after each particular read-write operation. */
        DMA_PDD_SetLinkChannel2(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopLinkedChannel); /* Set channel linked after transfer byte count reaches zero. */
        break;
      case LDD_DMA_CYCLE_STEAL_LINKING:
        DMA_PDD_SetChannelLinkingMode(DMA_BASE_PTR, ChannelNumber, DMA_PDD_CYCLE_STEAL_LINKING); /* Set channel linking mode. */
        DMA_PDD_SetLinkChannel1(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel); /* Set channel linked after each particular read-write operation. */
        break;
      case LDD_DMA_TRANSFER_COMPLETE_LINKING:
        DMA_PDD_SetChannelLinkingMode(DMA_BASE_PTR, ChannelNumber, DMA_PDD_TRANSFER_COMPLETE_LINKING); /* Set channel linking mode. */
        DMA_PDD_SetLinkChannel1(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopLinkedChannel); /* Set channel linked after transfer byte count reaches zero. */
        break;
    }
    if (DescriptorPtr->DisableAfterRequest) { /* Disable after request? */
      DMA_PDD_EnableRequestAutoDisable(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* {Bareboard RTOS Adapter} Critical section begin (RTOS function call is defined by Bareboard RTOS Adapter property) */
    EnterCritical();
    DescriptorRecordPtr->Initialized = TRUE; /* Mark channel as initialized. */
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->Interrupts) {   /* Interrupts enabled? */
      DMA_PDD_EnableTransferCompleteInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
      if (DescriptorPtr->OnComplete) { /* Is transfer complete event enabled? */
        ((DMA1_TDeviceData *)DeviceDataPtr)->EventMask[ChannelNumber] |= LDD_DMA_ON_COMPLETE;
      }
      if (DescriptorPtr->OnError) {    /* Is transfer error event enabled? */
        ((DMA1_TDeviceData *)DeviceDataPtr)->EventMask[ChannelNumber] |= LDD_DMA_ON_ERROR;
      }
    }
    /* DMA channel HW requests source settings */
    DMAMUX_PDD_WriteChannelConfigurationReg(DMAMUX0_BASE_PTR, ChannelNumber, 0U); /* Clear DMA MUX channel source register. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need MUX channel nor enabled hardware requests. */
      DMAMUX_PDD_SetChannelSource(DMAMUX0_BASE_PTR, ChannelNumber, DescriptorPtr->TriggerSource); /* Set MUX channel source. */
      if (DescriptorPtr->PeriodicTrigger) { /* Periodic trigger needed? */
        DMAMUX_PDD_EnableTrigger(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE);
      }
      DMAMUX_PDD_EnableChannel(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable channel. */
    }
    DMA_PDD_EnablePeripheralRequest(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable HW requests. */
    /* {Bareboard RTOS Adapter} Critical section ends (RTOS function call is defined by Bareboard RTOS Adapter property) */
    ExitCritical();
  }
  else {
    /* If channel has already been initialized then enable it only */
    /* {Bareboard RTOS Adapter} Critical section begin (RTOS function call is defined by Bareboard RTOS Adapter property) */
    EnterCritical();
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need enabled hardware requests. */
      DMA_PDD_EnablePeripheralRequest(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable HW requests */
    }
    /* {Bareboard RTOS Adapter} Critical section ends (RTOS function call is defined by Bareboard RTOS Adapter property) */
    ExitCritical();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  VerifyDescriptor (component DMA_LDD)
**
**     Description :
**         The method verifies a transfer descriptor of allocated channel 
**         defined by the pointer to its address. Returns TRUE if the 
**         channel's transfer descriptor is correct, FALSE if 
**         inconsistency is detected.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  /* Store source transfer size byte divider mask */
  LDD_DMA_TTransferSize SourceDividerMask, DestinationDividerMask;

  switch (DescriptorPtr->SourceTransferSize) {
    case DMA_PDD_8_BIT:
      SourceDividerMask = 0x00U;
      break;
    case DMA_PDD_16_BIT:
      SourceDividerMask = 0x01U;
      break;
    case DMA_PDD_32_BIT:
      SourceDividerMask = 0x03U;
      break;
    default:
      return FALSE;
  }
  switch (DescriptorPtr->DestinationTransferSize) {
    case DMA_PDD_8_BIT:
      DestinationDividerMask = 0x00U;
      break;
    case DMA_PDD_16_BIT:
      DestinationDividerMask = 0x01U;
      break;
    case DMA_PDD_32_BIT:
      DestinationDividerMask = 0x03U;
      break;
    default:
      return FALSE;
  }
  if ((!DescriptorPtr->AutoAlign) || (SourceDividerMask >= DestinationDividerMask)) { /* If source is auto-aligned, check destination only. */
    /* Is minor loop byte count a multiple of the destination transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & DestinationDividerMask) {
      return FALSE;                    /* If no, return. */
    }
    /* Is destination address aligned to destination transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->DestinationAddress) & DestinationDividerMask) {
      return FALSE;                    /* If no, return. */
    }
  }
  if ((!DescriptorPtr->AutoAlign) || (SourceDividerMask < DestinationDividerMask)) { /* If destination is auto-aligned, check source only. */
    /* Is minor loop byte count a multiple of the source transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & SourceDividerMask) {
      return FALSE;                    /* If no, return. */
    }
    /* Is source address aligned to source transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->SourceAddress) & SourceDividerMask) {
      return FALSE;                    /* If no, return. */
    }
  }
  return TRUE;                         /* Channel descriptor verified. */
}

/*
** ===================================================================
**     Method      :  GetRecord (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Pointer to the 
**         descriptor record of allocated channel is returned indirectly 
**         into the DescriptorRecordPtr parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA1_TDescriptorRecordPtr *DescriptorRecordAddressPtr)
{
  bool RecordFound = FALSE;

  if (((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    RecordFound = TRUE;
    *DescriptorRecordAddressPtr = ((DMA1_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Save descriptors record address. */
  }
  return RecordFound;
}

/*
** ===================================================================
**     Method      :  TransferCompleteInterrupt (component DMA_LDD)
**
**     Description :
**         Transfer complete interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA1_Channel2Interrupt)
{
  /* {Bareboard RTOS Adapter} ISR parameter is passed through the global variable */
  DMA1_TDeviceData* DeviceDataPtr = INT_DMA2__BAREBOARD_RTOS_ISRPARAM;
  if (DMA_PDD_GetChannelErrorFlags(DMA_BASE_PTR, DMA1_CHANNEL_2) != 0x00U) {
    if (((DeviceDataPtr)->EventMask[DMA1_CHANNEL_2] & LDD_DMA_ON_ERROR) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA1_CHANNEL_2]->DescriptorPtr->OnErrorEventPtr(DeviceDataPtr->ChannelRecord[DMA1_CHANNEL_2]->DescriptorPtr->UserDataPtr);
    }
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA1_CHANNEL_2, DMA_PDD_TRANSFER_COMPLETE_FLAG);
  } else {
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA1_CHANNEL_2, DMA_PDD_TRANSFER_COMPLETE_FLAG);
    if (((DeviceDataPtr)->EventMask[DMA1_CHANNEL_2] & LDD_DMA_ON_COMPLETE) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA1_CHANNEL_2]->DescriptorPtr->OnCompleteEventPtr(DeviceDataPtr->ChannelRecord[DMA1_CHANNEL_2]->DescriptorPtr->UserDataPtr);
    }
  }
}
/* END DMA1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.4 [05.11]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
